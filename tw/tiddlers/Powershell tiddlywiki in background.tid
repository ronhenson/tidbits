caption: PowerShell launching tiddlywiki in background
created: 20170529200619429
modified: 20200716152909389
revision: 0
tags: #Windows #Tidbit #Tech
title: Powershell tiddlywiki in background
type: text/vnd.tiddlywiki

! <$link to={{!!title}}>{{!!caption}}</$link>

!! Launch tiddlywiki node.js job in background

```powershell
Start-Job -Name AnyName {tiddlywiki d:\tw\RonAJournal --server 8080}
```
!! View the Jobs

```Powershell
Get-Job # All Jobs
Id     Name            PSJobTypeName   State         HasMoreData     Location             Command
--     ----            -------------   -----         -----------     --------             -------
19     tiddlywiki      BackgroundJob   Running       True            localhost            tiddlywiki d:\tw\RonAJ...
21     TechNotes       BackgroundJob   Running       True            localhost            tiddlywiki d:\tw\TechN...
23     tidbits         BackgroundJob   Running       True            localhost            tiddlywiki d:\tw\tidbi...
25     DesertViewRV    BackgroundJob   Running       True            localhost            tiddlywiki d:\DesertVi...

Get-Job 1              # Show job 1
Get-Job tiddlywiki     # jobs named tiddlywiki
Get-Job -State Failed  # All jobs that failed
```

!! remove a job

```
Remove-Job 1 # Remove Job 1
Remove-Job tiddlywiki # remove all jobs named tiddlywiki
Remove-Job -State Failed # remove jobs that failed
Remove-Job -State Completed 
```

!! Retrieving Job Results

 To get job results, you use the Receive-Job cmdlet. You can specify the job by name or ID. For example, to get the results for job 1, you'd run the command:

```
Receive-Job 1
```

 But let's say you want to get the results again, so you try running the same command:

```
Receive-Job 1
```
No matter how many times you run this command, you won't get any results. To see why, let's run a different command to look at that job:

```
Get-Job 1
Id     Name            PSJobTypeName   State         HasMoreData     Location             Command
--     ----            -------------   -----         -----------     --------             -------
19     tiddlywiki      BackgroundJob   Running       False            localhost            tiddlywiki d:\tw\RonAJ...
```
the job queue has no more data.  ( Look under HasMoreData column)

 When you receive a job, PowerShell writes all the data to the pipeline and clears the queue unless you use the -Keep parameter, like this:

```
Receive-Job 3 -Keep
```
As long as you continue to use the `-Keep` parameter, PowerShell will retain the job results. What I typically do is save the results to a variable in addition to keeping them. This way, I can work with the results in the variable and retrieve them as many times as necessary.

 For example, the following code saves the results from job 3 to a variable named $events, then uses those results:

```
$events = Receive-Job 3 -Keep
$events.count
$events | select Source -Unique
```

 You can work with job results just as if you had run the command interactively:

```
Receive-Job TempDir -Keep | measure Length -Sum
```
However, as I mentioned previously, you might want to save the results to a variable first by running a command such as:

```
$data = Receive-Job TempDir -Keep | measure Length -Sum
$data.sum/1mb
```

Don't forget to keep the results every time you run a Receive-Job command. One step you might try in PowerShell 3.0 is to set a default parameter value for Receive-Job:

```
$PSDefaultParameterValues.Add("Receive-job:Keep",$True)
```

If you run this command, PowerShell will automatically set the -Keep parameter to $True in the current session. If you want this behavior all the time, you need to put this command into your PowerShell profile script.

!! Stopping and Waiting for Jobs

By now I hope you're realizing the benefit of PowerShell background jobs. You can execute a long running task on 1, 10, or 1,000 computers and retrieve the results later. Just remember to get the results before you close your PowerShell session.

There might be times when you need to stop a job. For example, suppose you started running a job like this:

```
Invoke-Command {dir c:\ -Recurse } -ComputerName
  $computers -AsJob -JobName RemoteDir
```
You then realize you made a mistake and want to kill the job. To do that, you simply use the Stop-Job cmdlet:

```
Stop-Job RemoteDir
```
Keep in mind that there might still be results worth receiving and saving, even though you stopped the job.

Finally, although the whole point of a background job is to get your prompt back so you can keep working, there might be situations in which you need the job to finish before you can do anything else. For example, in a script, you might kick off a job, execute some other code, then need the job results before continuing. This is where the `Wait-Job` cmdlet comes in handy.

With `Wait-Job`, PowerShell will block until the job completes. By default, the cmdlet waits indefinitely, but you can set a timeout value (in seconds). Typically, I use `Wait-Job` interactively when I need the job results but don't want to keep typing `Get-Job` to check the status.

You can pipe a job object to Wait-Job:

```
Invoke-Command {Get-Hotfix} -ComputerName $computers
  -AsJob -JobName hotfix | Wait-Job
```

You'll have to wait for the job to complete, but you'll receive the job results when the prompt returns. You can even include the code that retains and uses the job results by using a series of commands like this:

```
$hot = Invoke-Command {Get-Hotfix} -ComputerName
  $computers -AsJob -JobName hotfix | Wait-Job |
  Receive-Job -Keep
$hot | group PSComputername -NoElement
$hot | where PSComputername -eq 'chi-dc01' |
  sort Description | group Description -NoElement |
  sort
```

This way, you can keep the results in the job queue. Figure 11 shows sample results. Although you typically use background jobs for long-running commands, PowerShell doesn't really care if you use them for this purpose.

Including the Code that Retains and Uses the Job Results

!! Be More Efficient and Productive

I haven't covered every parameter of every job cmdlet in every scenario. So, you need to take some time to read the full Help file and check out the examples for all the cmdlets I demonstrated here. In addition, read the Help topics `about_Jobs`, `about_Job_Details`, and `about_Remote_Jobs`. (By the way, if you look at the documentation, you'll see the Suspend-Job and Resume-Job cmdlets. Those cmdlets apply only to workflow jobs and not anything I discussed here.) As PowerShell continues to dominate the world of the IT professional, it's essential that you understand how to use background jobs so that you can be more efficient and productive.